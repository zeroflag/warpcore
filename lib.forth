: C!
  DUP @ $FF00 AND
  ROT $FF AND OR
  SWAP !
EXIT

: C@  @ $FF AND EXIT
: ++  DUP @ 1+ SWAP ! EXIT
: +=  DUP @ ROT + SWAP ! EXIT
: -=  DUP @ ROT - SWAP ! EXIT
: DP  $182 EXIT

: MAIN  $0190 EXIT
: BASE  $0184 EXIT
: ENTRY DP @ MAIN 1+ ! EXIT IMMEDIATE

: ,   DP @  ! DP ++ DP ++ EXIT
: C,  DP @ C! DP ++ EXIT

: CODE R>    DUP C@ SWAP 1+  >R C, EXIT
: SUB  R> 1+ DUP  @ SWAP 2 + >R  , EXIT

: ; CODE EXIT EXIT IMMEDIATE

: KEY  2  IN ;
: RND  3  IN ;
: EMIT 1 OUT ;

: LITERAL CODE LIT , ;

: TRUE       -1 LITERAL ; IMMEDIATE
: FALSE       0 LITERAL ; IMMEDIATE
: CELL        2 LITERAL ; IMMEDIATE
: SCRATCH $7F7E LITERAL ; IMMEDIATE

: CELLS CELL * ;
: ALLOT DP @ + DP ! ;
: EXEC >R EXIT ;
: DEPTH SP $02 - CELL / ;

: MARK    DP @ 0 , ;
: RESOLVE DP @ OVER - SWAP ! ;

: IF      CODE JZ  MARK ; IMMEDIATE
: ELSE    CODE JMP MARK SWAP RESOLVE ; IMMEDIATE
: THEN    RESOLVE ; IMMEDIATE

: BEGIN   DP @ ; IMMEDIATE
: UNTIL   CODE JZ  DP @ - , ; IMMEDIATE
: AGAIN   CODE JMP DP @ - , ; IMMEDIATE

: WHILE   CODE JZ  MARK ; IMMEDIATE
: REPEAT  SWAP CODE JMP DP @ - , RESOLVE ; IMMEDIATE

: FOR     CODE >R DP @ ; IMMEDIATE
: NEXT
  CODE R@ CODE JZ  MARK
  CODE R> CODE 1-  CODE >R
  SWAP
  CODE JMP DP @ - ,
  RESOLVE
  CODE R> CODE DROP
; IMMEDIATE

: ( BEGIN KEY 41 = UNTIL ; IMMEDIATE
: \ BEGIN KEY DUP 10 = SWAP 13 = OR UNTIL ; IMMEDIATE

: CASE 0 ; IMMEDIATE
: OF
  CODE OVER CODE =
  CODE JZ   MARK
  CODE DROP
; IMMEDIATE

: ENDOF
    SWAP 1+ SWAP
    CODE JMP MARK SWAP
    RESOLVE
    SWAP
; IMMEDIATE

: ENDCASE
  BEGIN
    DUP 0 >
  WHILE
    1- SWAP RESOLVE
  REPEAT
  DROP
; IMMEDIATE

: NON-ZERO? C@ 0 <> ;

: PRINT
  BEGIN
    DUP NON-ZERO?
  WHILE
    DUP C@ EMIT
    1+
  REPEAT
  DROP ;

: "
  CODE LIT MARK ( Mark1: addr of string )
  CODE JMP MARK ( Mark2: length )
  SWAP
  DP @ SWAP !     ( Resolve Mark1 )
  BEGIN
    KEY DUP 34 <>
  WHILE
    C,
  REPEAT
  DROP
  0 C,
  RESOLVE         ( Resolve Mark2 )
; IMMEDIATE

: ?DUP  DUP 0 <> IF DUP THEN ;
: 2DUP  OVER OVER ;
: 2DROP DROP DROP ;
: 3DROP DROP DROP DROP ;
: -ROT  ROT ROT ;
: TUCK  DUP ROT ROT ;

: BETWEEN? OVER >= -ROT <= AND ;

: CR 10 EMIT ;

: /MOD 2DUP % -ROT / ;

: C= C@ SWAP C@ = ;

: STR=
  BEGIN
    2DUP C=
    OVER NON-ZERO? AND
    OVER NON-ZERO? AND
  WHILE
    1+ SWAP 1+
  REPEAT
  C= ;

: STRLEN
  0
  BEGIN
    OVER NON-ZERO?
  WHILE
    1+ SWAP
    1+ SWAP
  REPEAT
  NIP ;

: CHAR
  WORD DUP STRLEN 1 <> IF
    " CHAR needs one character." ABORT
  ELSE
    C@ LITERAL
  THEN
; IMMEDIATE

: . ( n -- )
    DUP 0 < IF CHAR - EMIT -1 * THEN
    10 /MOD ?DUP IF . THEN
    CHAR 0 + EMIT ;

: NEG? C@ CHAR - = ;
: HEX? C@ CHAR $ = ;
: BIN? C@ CHAR % = ;

: 0..9? CHAR 0 SWAP CHAR 9 BETWEEN? ;

: >DIGIT
  C@ DUP 0..9? IF
    CHAR 0 -
  ELSE
    CHAR A - 10 +
  THEN ;

: DIGIT?
  BASE @ 10 <= IF
    CHAR 0 SWAP C@ 47 BASE @ + BETWEEN?
    EXIT
  THEN
  BASE @ 16 <= IF
    C@ DUP 0..9?
    CHAR A ROT 54 BASE @ + BETWEEN?
    OR
    EXIT
  THEN
  FALSE ;

: >NUMBER ( s -- n bool )
  DUP HEX? IF
    1+ 16
  ELSE
    DUP BIN? IF 1+ 2 ELSE 10 THEN
  THEN
  BASE !
  DUP NEG? IF 1+ -1 ELSE 1 THEN
  SWAP 0
  ( sign str result )
  BEGIN
    OVER NON-ZERO?
  WHILE
    OVER DIGIT? INVERT IF 3DROP FALSE EXIT THEN
    BASE @ * OVER >DIGIT +
    SWAP 1+ SWAP
  REPEAT
  NIP * TRUE ;

: ERR-NAN " Not a number." ABORT ;

: .DB
  DP @ ( save current DP )
  WORD >NUMBER IF DP ! ELSE ERR-NAN THEN
  BEGIN
    WORD DUP " .END" STR= INVERT
  WHILE
    >NUMBER IF C, ELSE ERR-NAN THEN
  REPEAT
  DROP DP ! ( restore DP )
; IMMEDIATE

: [ DP @ SCRATCH DP ! ; IMMEDIATE
: ] CODE EXIT
    DP !
    SCRATCH EXEC ; IMMEDIATE

: CREATE
  POSTPONE :
  POSTPONE IMMEDIATE
  CODE LIT  MARK
  CODE CALL SUB LITERAL
  CODE EXIT
  DP @ SWAP !
; IMMEDIATE

: CONSTANT
  POSTPONE :
  POSTPONE IMMEDIATE
  CODE LIT ,
  CODE CALL SUB LITERAL
  CODE EXIT
; IMMEDIATE

: VARIABLE
  POSTPONE CREATE
  0 ,
; IMMEDIATE

: MIN OVER OVER < IF DROP ELSE NIP  THEN ;
: MAX OVER OVER < IF NIP  ELSE DROP THEN ;
